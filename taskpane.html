import { Hono } from "npm:hono";
import { cors } from "npm:hono/cors";
import { logger } from "npm:hono/logger";
import { createClient } from "jsr:@supabase/supabase-js@2.49.8";
import JSZip from "npm:jszip@3.10.1";
import * as kv from "./kv_store.tsx";
import { generateManifestXml, generateTaskpaneHtml, generateReadmeText, generateServeScript } from "./addin_generator.tsx";
import { runAgentStep } from "./excel_agent.tsx";
import { generateAgentTaskpaneHtml } from "./taskpane_content.tsx";
import {
  extractTrainingPatterns,
  getTrainingPatterns,
  generateFinancialModel,
  modelToCellData,
  getModelTypes,
} from "./ai_engine.tsx";
import { parseExcelBuffer, extractRealPatterns } from "./xlsx_parser.tsx";

const app = new Hono();

// Enable logger
app.use("*", logger(console.log));

// Enable CORS for all routes and methods
app.use(
  "/*",
  cors({
    origin: "*",
    allowHeaders: ["Content-Type", "Authorization"],
    allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    exposeHeaders: ["Content-Length", "Content-Disposition"],
    maxAge: 600,
  })
);

// Supabase admin client (for auth operations)
const supabaseAdmin = () =>
  createClient(
    Deno.env.get("SUPABASE_URL")!,
    Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!
  );

// Storage bucket name
const TRAINING_BUCKET = "make-f3f66941-training-models";

// Public bucket for add-in manifest (XML MIME is fine — Supabase doesn't normalise it).
// The taskpane HTML itself is hosted on GitHub Pages to guarantee correct text/html MIME.
const ADDIN_PUBLIC_BUCKET = "make-f3f66941-addin-public";

// ── Taskpane Hosting Strategy ────────────────────────────
// The taskpane HTML is hosted on GitHub Pages (emad-log.github.io/modelforge-addin).
// GitHub Pages guarantees correct Content-Type: text/html, which Supabase Storage cannot.
// The server generates the HTML on-demand for download; users commit it to their GitHub repo.
// A cached override URL can be stored in KV for custom deployments.
let CACHED_PLATFORM_TASKPANE_URL = "";

// Load any custom override URL from KV on startup
(async () => {
  try {
    const stored = await kv.get("platform:taskpane-url");
    if (stored) {
      CACHED_PLATFORM_TASKPANE_URL = String(stored);
      console.log(`Custom taskpane URL override from KV: ${CACHED_PLATFORM_TASKPANE_URL}`);
    }
  } catch (err) {
    console.log(`Startup init warning (non-fatal): ${err}`);
  }
})();

// Helper: get the best available taskpane URL
function getTaskpaneUrl(override?: string): string {
  return override || CACHED_PLATFORM_TASKPANE_URL || "";
}

// Helper: verify auth and get user ID
async function getAuthUser(request: Request): Promise<{ id: string; email: string } | null> {
  const accessToken = request.headers.get("Authorization")?.split(" ")[1];
  if (!accessToken) return null;
  const supabase = supabaseAdmin();
  const { data, error } = await supabase.auth.getUser(accessToken);
  if (error || !data?.user?.id) return null;
  return { id: data.user.id, email: data.user.email || "" };
}

// ── Health check ────────────────────────────────────────
app.get("/make-server-f3f66941/health", (c) => {
  return c.json({ status: "ok", timestamp: new Date().toISOString() });
});

// ── Auth: Sign Up ───────────────────────────────────────
app.post("/make-server-f3f66941/auth/signup", async (c) => {
  try {
    const { email, password, name, role } = await c.req.json();
    if (!email || !password || !name) {
      return c.json({ error: "Missing required fields: email, password, name" }, 400);
    }
    const supabase = supabaseAdmin();
    const { data, error } = await supabase.auth.admin.createUser({
      email,
      password,
      user_metadata: { name, role: role || "Analyst" },
      // Automatically confirm the user's email since an email server hasn't been configured.
      email_confirm: true,
    });
    if (error) {
      console.log(`Auth signup error for ${email}: ${error.message}`);
      return c.json({ error: `Signup failed: ${error.message}` }, 400);
    }

    // Store user profile in KV
    await kv.set(`user:${data.user.id}:profile`, {
      id: data.user.id,
      email,
      name,
      role: role || "Analyst",
      initials: name.split(" ").map((w: string) => w[0]).join("").toUpperCase().slice(0, 2),
      createdAt: new Date().toISOString(),
    });

    console.log(`User created successfully: ${email}`);
    return c.json({ user: data.user });
  } catch (err) {
    console.log(`Unexpected error during signup: ${err}`);
    return c.json({ error: `Unexpected signup error: ${err}` }, 500);
  }
});

// ── Models: List ────────────────────────────────────────
app.get("/make-server-f3f66941/models", async (c) => {
  try {
    const models = await kv.getByPrefix("model:");
    // Filter out version history entries, only return model objects
    const modelList = models.filter((m: any) => m && m.id && !m.isVersion);
    return c.json({ models: modelList });
  } catch (err) {
    console.log(`Error listing models: ${err}`);
    return c.json({ error: `Failed to list models: ${err}` }, 500);
  }
});

// ── Models: Get by ID ───────────────────────────────────
app.get("/make-server-f3f66941/models/:id", async (c) => {
  try {
    const id = c.req.param("id");
    const model = await kv.get(`model:${id}`);
    if (!model) {
      return c.json({ error: `Model not found: ${id}` }, 404);
    }
    return c.json({ model });
  } catch (err) {
    console.log(`Error getting model ${c.req.param("id")}: ${err}`);
    return c.json({ error: `Failed to get model: ${err}` }, 500);
  }
});

// ── Models: Create / Update ─────────────────────────────
app.post("/make-server-f3f66941/models", async (c) => {
  try {
    const body = await c.req.json();
    const { id, name, type, deal, assumptions, status, assignee, assigneeName } = body;

    if (!id || !name) {
      return c.json({ error: "Missing required fields: id, name" }, 400);
    }

    // Check if model already exists for versioning
    const existing = await kv.get(`model:${id}`);
    const now = new Date().toISOString();

    if (existing) {
      // Save a version snapshot before overwriting
      const versionKey = `model:${id}:v:${Date.now()}`;
      await kv.set(versionKey, {
        ...existing,
        isVersion: true,
        versionTimestamp: now,
      });
    }

    const model = {
      id,
      name,
      type: type || "LBO",
      deal: deal || "",
      assumptions: assumptions || {},
      status: status || "Draft",
      assignee: assignee || "",
      assigneeName: assigneeName || "",
      createdAt: existing?.createdAt || now,
      updatedAt: now,
      version: (existing?.version || 0) + 1,
    };

    await kv.set(`model:${id}`, model);

    // Log activity
    await logActivity({
      action: existing ? "updated" : "created",
      target: name,
      user: assigneeName || "System",
      modelId: id,
    });

    console.log(`Model ${existing ? "updated" : "created"}: ${name} (${id})`);
    return c.json({ model });
  } catch (err) {
    console.log(`Error saving model: ${err}`);
    return c.json({ error: `Failed to save model: ${err}` }, 500);
  }
});

// ── Models: Delete ──────────────────────────────────────
app.delete("/make-server-f3f66941/models/:id", async (c) => {
  try {
    const id = c.req.param("id");
    const model = await kv.get(`model:${id}`);
    if (!model) {
      return c.json({ error: `Model not found: ${id}` }, 404);
    }

    await kv.del(`model:${id}`);

    await logActivity({
      action: "deleted",
      target: model.name,
      user: model.assigneeName || "System",
      modelId: id,
    });

    console.log(`Model deleted: ${model.name} (${id})`);
    return c.json({ success: true });
  } catch (err) {
    console.log(`Error deleting model ${c.req.param("id")}: ${err}`);
    return c.json({ error: `Failed to delete model: ${err}` }, 500);
  }
});

// ── Models: Version History ─────────────────────────────
app.get("/make-server-f3f66941/models/:id/versions", async (c) => {
  try {
    const id = c.req.param("id");
    const versions = await kv.getByPrefix(`model:${id}:v:`);
    const sorted = versions
      .filter((v: any) => v && v.isVersion)
      .sort((a: any, b: any) => new Date(b.versionTimestamp).getTime() - new Date(a.versionTimestamp).getTime());
    return c.json({ versions: sorted });
  } catch (err) {
    console.log(`Error getting versions for model ${c.req.param("id")}: ${err}`);
    return c.json({ error: `Failed to get versions: ${err}` }, 500);
  }
});

// ── Activity Feed ───────────────────────────────────────
async function logActivity(entry: {
  action: string;
  target: string;
  user: string;
  modelId?: string;
}) {
  try {
    const activityId = `activity:${Date.now()}:${Math.random().toString(36).slice(2, 8)}`;
    await kv.set(activityId, {
      ...entry,
      id: activityId,
      timestamp: new Date().toISOString(),
    });
  } catch (err) {
    console.log(`Error logging activity: ${err}`);
  }
}

app.get("/make-server-f3f66941/activity", async (c) => {
  try {
    const activities = await kv.getByPrefix("activity:");
    const sorted = activities
      .filter((a: any) => a && a.timestamp)
      .sort((a: any, b: any) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
      .slice(0, 20); // Last 20 activities
    return c.json({ activities: sorted });
  } catch (err) {
    console.log(`Error listing activity: ${err}`);
    return c.json({ error: `Failed to list activity: ${err}` }, 500);
  }
});

// ── Sync Events (for Excel Hub) ─────────────────────────
app.post("/make-server-f3f66941/sync/event", async (c) => {
  try {
    const { workbook, action, direction, user, modelId, success } = await c.req.json();
    const syncId = `sync:${Date.now()}:${Math.random().toString(36).slice(2, 8)}`;

    await kv.set(syncId, {
      id: syncId,
      workbook,
      action,
      direction,
      user,
      modelId,
      success: success !== false,
      timestamp: new Date().toISOString(),
    });

    console.log(`Sync event logged: ${action} for ${workbook}`);
    return c.json({ success: true });
  } catch (err) {
    console.log(`Error logging sync event: ${err}`);
    return c.json({ error: `Failed to log sync event: ${err}` }, 500);
  }
});

app.get("/make-server-f3f66941/sync/history", async (c) => {
  try {
    const events = await kv.getByPrefix("sync:");
    const sorted = events
      .filter((e: any) => e && e.timestamp)
      .sort((a: any, b: any) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
      .slice(0, 20);
    return c.json({ events: sorted });
  } catch (err) {
    console.log(`Error listing sync history: ${err}`);
    return c.json({ error: `Failed to list sync history: ${err}` }, 500);
  }
});

// ── Seed demo data ─────────────────────────────────────
// No-op — the platform starts empty. Users upload real models and create real data.
app.post("/make-server-f3f66941/seed", async (c) => {
  return c.json({ message: "Platform ready. Upload models to get started.", seeded: false });
});

// ── Excel Add-in: Centralized info (public URL + manifest) ──
app.get("/make-server-f3f66941/addin/info", (c) => {
  const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
  const apiBase = `${supabaseUrl}/functions/v1/make-server-f3f66941`;
  const ghTaskpaneUrl = "https://emad-log.github.io/modelforge-addin/taskpane.html";
  return c.json({
    taskpaneUrl: ghTaskpaneUrl,
    manifestDownloadUrl: `${apiBase}/addin/manifest`,
    hosting: "github-pages",
    githubRepo: "https://github.com/Emad-log/modelforge-addin",
    description: "Taskpane hosted on GitHub Pages at emad-log.github.io. Commit taskpane.html to update.",
  });
});

// ── Excel Add-in: Register platform URL ─────────────────
// Called by the Add-in Builder page on mount to store the platform origin.
// This URL is used for all manifest generation so every path produces the correct URL.
app.post("/make-server-f3f66941/addin/register-platform", async (c) => {
  try {
    const { taskpaneUrl } = await c.req.json();
    if (!taskpaneUrl || typeof taskpaneUrl !== "string") {
      return c.json({ error: "Missing required field: taskpaneUrl" }, 400);
    }

    // Validate it looks like a URL
    try { new URL(taskpaneUrl); } catch {
      return c.json({ error: "Invalid URL format" }, 400);
    }

    // Store in KV for persistence across cold-starts
    await kv.set("platform:taskpane-url", taskpaneUrl);
    CACHED_PLATFORM_TASKPANE_URL = taskpaneUrl;

    // Upload a correct manifest.xml to Supabase Storage (for IT admin org-wide deployment)
    try {
      const supabase = supabaseAdmin();
      const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
      const apiBase = `${supabaseUrl}/functions/v1/make-server-f3f66941`;
      const manifestXml = generateManifestXml({ apiBaseUrl: apiBase, taskpaneUrl });
      const manifestBlob = new Blob([manifestXml], { type: "application/xml" });
      await supabase.storage
        .from(ADDIN_PUBLIC_BUCKET)
        .upload("manifest.xml", manifestBlob, { contentType: "application/xml", upsert: true });
      const manifestPublicUrl = `${supabaseUrl}/storage/v1/object/public/${ADDIN_PUBLIC_BUCKET}/manifest.xml`;
      console.log(`Updated manifest.xml in storage with platform URL: ${taskpaneUrl}`);
      console.log(`Manifest public URL for IT admin: ${manifestPublicUrl}`);
    } catch (storageErr) {
      console.log(`Warning: failed to update manifest in storage (non-fatal): ${storageErr}`);
    }

    console.log(`Platform taskpane URL registered: ${taskpaneUrl}`);
    return c.json({ success: true, taskpaneUrl });
  } catch (err) {
    console.log(`Error registering platform URL: ${err}`);
    return c.json({ error: `Failed to register platform URL: ${err}` }, 500);
  }
});

// ── Excel Add-in: Download ZIP Package ──────────────────
app.get("/make-server-f3f66941/addin/download", async (c) => {
  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const apiBase = `${supabaseUrl}/functions/v1/make-server-f3f66941`;
    const anonKey = Deno.env.get("SUPABASE_ANON_KEY") || "";

    const customTaskpaneUrl = c.req.query("taskpaneUrl");
    const taskpaneUrl = customTaskpaneUrl || getTaskpaneUrl() || "https://emad-log.github.io/modelforge-addin/taskpane.html";

    const html = generateAgentTaskpaneHtml(apiBase, anonKey);

    // Build a Vercel-ready project structure inside the ZIP:
    //   /public/taskpane.html   — the static file Vercel serves
    //   /vercel.json            — routing & headers config
    //   /manifest.xml           — sideload into Excel (top-level for easy access)
    //   /serve.js               — fallback local dev server
    //   /README.txt             — instructions
    const zip = new JSZip();
    zip.file("manifest.xml", generateManifestXml({ apiBaseUrl: apiBase, taskpaneUrl }));
    zip.file("public/taskpane.html", html);
    zip.file("public/index.html", html); // so root URL also works
    zip.file("taskpane.html", html);     // top-level copy for local dev
    zip.file("vercel.json", JSON.stringify({
      headers: [
        {
          source: "/(.*)",
          headers: [
            { key: "Access-Control-Allow-Origin", value: "*" },
            { key: "X-Frame-Options", value: "ALLOWALL" },
            { key: "Content-Security-Policy", value: "frame-ancestors *" },
          ],
        },
      ],
    }, null, 2));
    zip.file("README.txt", generateReadmeText(taskpaneUrl));
    zip.file("serve.js", generateServeScript());

    const content = await zip.generateAsync({ type: "uint8array" });

    console.log(`Add-in ZIP generated: ${content.byteLength} bytes (taskpane: ${taskpaneUrl.substring(0, 80)}...)`);
    return new Response(content, {
      status: 200,
      headers: {
        "Content-Type": "application/zip",
        "Content-Disposition": "attachment; filename=ModelForge-Excel-Addin-v3.1.0.zip",
        "Content-Length": String(content.byteLength),
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Expose-Headers": "Content-Disposition",
      },
    });
  } catch (err) {
    console.log(`Error generating add-in ZIP: ${err}`);
    return c.json({ error: `Failed to generate add-in package: ${err}` }, 500);
  }
});

// ── Excel Add-in: Download manifest.xml only ────────────
app.get("/make-server-f3f66941/addin/manifest", (c) => {
  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const apiBase = `${supabaseUrl}/functions/v1/make-server-f3f66941`;
    const customTaskpaneUrl = c.req.query("taskpaneUrl");
    const taskpaneUrl = customTaskpaneUrl || getTaskpaneUrl() || "https://emad-log.github.io/modelforge-addin/taskpane.html";
    const xml = generateManifestXml({ apiBaseUrl: apiBase, taskpaneUrl });
    return new Response(xml, {
      status: 200,
      headers: {
        "Content-Type": "application/xml",
        "Content-Disposition": "attachment; filename=manifest.xml",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Expose-Headers": "Content-Disposition",
      },
    });
  } catch (err) {
    console.log(`Error generating manifest: ${err}`);
    return c.json({ error: `Failed to generate manifest: ${err}` }, 500);
  }
});

// ── Excel Add-in: Serve taskpane HTML (for Office.js SourceLocation) ──
app.get("/make-server-f3f66941/addin/taskpane", (c) => {
  try {
    const apiBase = `${Deno.env.get("SUPABASE_URL")}/functions/v1/make-server-f3f66941`;
    const anonKey = Deno.env.get("SUPABASE_ANON_KEY") || "";
    const html = generateAgentTaskpaneHtml(apiBase, anonKey);
    return new Response(html, {
      status: 200,
      headers: {
        "Content-Type": "text/html; charset=utf-8",
        "Access-Control-Allow-Origin": "*",
      },
    });
  } catch (err) {
    console.log(`Error serving taskpane: ${err}`);
    return c.json({ error: `Failed to serve taskpane: ${err}` }, 500);
  }
});

// ── AI Training: Upload model file ──────────────────────
app.post("/make-server-f3f66941/ai/upload", async (c) => {
  try {
    const contentType = c.req.header("Content-Type") || "";

    if (contentType.includes("multipart/form-data")) {
      const body = await c.req.parseBody();
      const file = body["file"];
      if (!file || !(file instanceof File)) {
        return c.json({ error: "No file provided. Include a 'file' field in multipart form data." }, 400);
      }

      const fileName = file.name || `upload-${Date.now()}.xlsx`;
      const fileType = (body["type"] as string) || "LBO";
      const storagePath = `uploads/${Date.now()}-${fileName}`;
      const arrayBuffer = await file.arrayBuffer();
      const uint8 = new Uint8Array(arrayBuffer);

      // Upload to Supabase Storage
      const supabase = supabaseAdmin();
      const { error: uploadError } = await supabase.storage
        .from(TRAINING_BUCKET)
        .upload(storagePath, uint8, {
          contentType: file.type || "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        });

      if (uploadError) {
        console.log(`Storage upload error for ${fileName}: ${uploadError.message}`);
        return c.json({ error: `File upload failed: ${uploadError.message}` }, 500);
      }

      // ── Real XLSX Parsing ─────────────────────────────
      // Parse the actual Excel file to extract real structure
      let parsedWorkbook = null;
      let realPattern = null;
      let parseError = null;
      try {
        parsedWorkbook = parseExcelBuffer(arrayBuffer, fileName, fileType);
        console.log(`XLSX parsed: ${fileName} — ${parsedWorkbook.sheetCount} sheets, ${parsedWorkbook.totalFormulas} formulas, ${parsedWorkbook.totalCells} cells, detected type: ${parsedWorkbook.detectedType}`);
      } catch (parseErr) {
        parseError = String(parseErr);
        console.log(`XLSX parse warning for ${fileName} (will fall back to template patterns): ${parseErr}`);
      }

      // Store metadata in KV
      const uploadId = `training-model:${Date.now()}:${Math.random().toString(36).slice(2, 8)}`;
      const metadata: any = {
        id: uploadId,
        name: fileName,
        type: fileType,
        detectedType: parsedWorkbook?.detectedType || fileType,
        size: file.size,
        sizeFormatted: file.size > 1024 * 1024
          ? `${(file.size / (1024 * 1024)).toFixed(1)} MB`
          : `${(file.size / 1024).toFixed(0)} KB`,
        storagePath,
        status: "Processing",
        uploadedAt: new Date().toISOString(),
        parsed: !!parsedWorkbook,
        sheetCount: parsedWorkbook?.sheetCount || 0,
        totalFormulas: parsedWorkbook?.totalFormulas || 0,
        totalCells: parsedWorkbook?.totalCells || 0,
        sheetNames: parsedWorkbook?.sheets.map((s: any) => s.name) || [],
      };

      await kv.set(uploadId, metadata);

      // Extract real patterns from parsed workbook, or fall back to template patterns
      if (parsedWorkbook) {
        try {
          realPattern = await extractRealPatterns(uploadId, parsedWorkbook);
          await kv.set(uploadId, { ...metadata, status: "Processed", processedAt: new Date().toISOString(), patternId: realPattern.id });
          console.log(`Real training patterns extracted from ${fileName}: ${realPattern.id} (${parsedWorkbook.totalFormulas} formulas, ${parsedWorkbook.totalCells} cells)`);
        } catch (patternErr) {
          console.log(`Real pattern extraction failed for ${fileName}, falling back to template: ${patternErr}`);
          // Fall back to template-based extraction immediately
          try {
            await kv.set(uploadId, { ...metadata, status: "Processed", processedAt: new Date().toISOString() });
            await extractTrainingPatterns(uploadId, fileName, fileType);
            console.log(`Fallback template patterns extracted for: ${fileName}`);
          } catch (e) {
            console.log(`Error in fallback pattern extraction: ${e}`);
          }
        }
      } else {
        // No parse available — use template-based patterns
        try {
          await kv.set(uploadId, { ...metadata, status: "Processed", processedAt: new Date().toISOString() });
          await extractTrainingPatterns(uploadId, fileName, fileType);
          console.log(`Template patterns extracted for: ${fileName}`);
        } catch (e) {
          console.log(`Error updating training model status: ${e}`);
        }
      }

      await logActivity({
        action: parsedWorkbook
          ? `uploaded & parsed for AI training (${parsedWorkbook.totalFormulas} formulas extracted)`
          : "uploaded for AI training",
        target: fileName,
        user: "System",
      });

      console.log(`Training model uploaded: ${fileName} (${metadata.sizeFormatted})`);
      return c.json({
        upload: metadata,
        parsed: !!parsedWorkbook,
        pattern: realPattern ? { id: realPattern.id, sheetCount: parsedWorkbook?.sheetCount, totalFormulas: parsedWorkbook?.totalFormulas } : null,
        parseError,
      });
    }

    return c.json({ error: "Expected multipart/form-data with a 'file' field" }, 400);
  } catch (err) {
    console.log(`Error uploading training model: ${err}`);
    return c.json({ error: `Upload failed: ${err}` }, 500);
  }
});

// ── AI Training: List uploaded models ───────────────────
app.get("/make-server-f3f66941/ai/models", async (c) => {
  try {
    const models = await kv.getByPrefix("training-model:");
    const sorted = models
      .filter((m: any) => m && m.id)
      .sort((a: any, b: any) => new Date(b.uploadedAt).getTime() - new Date(a.uploadedAt).getTime());
    return c.json({ models: sorted });
  } catch (err) {
    console.log(`Error listing training models: ${err}`);
    return c.json({ error: `Failed to list training models: ${err}` }, 500);
  }
});

// ── AI Training: Create training job ────────────────────
// Training jobs in Path A (context-rich prompting) don't actually train a model —
// they extract/consolidate patterns from selected uploaded files.
// The job completes immediately since real parsing already happened at upload time.
app.post("/make-server-f3f66941/ai/training-jobs", async (c) => {
  try {
    const { name, type, modelIds } = await c.req.json();
    if (!name) {
      return c.json({ error: "Missing required field: name" }, 400);
    }

    const jobId = `training-job:${Date.now()}:${Math.random().toString(36).slice(2, 8)}`;

    // Count how many patterns exist for the selected models
    const patterns = await kv.getByPrefix("pattern:");
    const relevantPatterns = patterns.filter((p: any) =>
      p && p.id && (!type || p.modelType === type || p.detectedType === type)
    );

    const job = {
      id: jobId,
      name,
      type: type || "LBO",
      modelIds: modelIds || [],
      modelsCount: (modelIds || []).length,
      status: "complete",
      progress: 100,
      patternsConsolidated: relevantPatterns.length,
      startedAt: new Date().toISOString(),
      completedAt: new Date().toISOString(),
    };

    await kv.set(jobId, job);
    await logActivity({ action: `consolidated ${relevantPatterns.length} patterns for`, target: name, user: "AI Engine" });

    console.log(`Training job created and completed: ${name} (${jobId}) — ${relevantPatterns.length} patterns consolidated`);
    return c.json({ job });
  } catch (err) {
    console.log(`Error creating training job: ${err}`);
    return c.json({ error: `Failed to create training job: ${err}` }, 500);
  }
});

// ── AI Training: List training jobs ─────────────────────
app.get("/make-server-f3f66941/ai/training-jobs", async (c) => {
  try {
    const jobs = await kv.getByPrefix("training-job:");
    const sorted = jobs
      .filter((j: any) => j && j.id)
      .sort((a: any, b: any) => new Date(b.startedAt).getTime() - new Date(a.startedAt).getTime());
    return c.json({ jobs: sorted });
  } catch (err) {
    console.log(`Error listing training jobs: ${err}`);
    return c.json({ error: `Failed to list training jobs: ${err}` }, 500);
  }
});

// ── AI Training: Extract patterns from uploaded model ───
app.post("/make-server-f3f66941/ai/extract-patterns", async (c) => {
  try {
    const { modelId, fileName, modelType } = await c.req.json();
    if (!modelId || !fileName) {
      return c.json({ error: "Missing required fields: modelId, fileName" }, 400);
    }
    const pattern = await extractTrainingPatterns(modelId, fileName, modelType || "LBO");
    console.log(`Patterns extracted from ${fileName}: ${pattern.id}`);
    return c.json({ pattern });
  } catch (err) {
    console.log(`Error extracting patterns: ${err}`);
    return c.json({ error: `Failed to extract patterns: ${err}` }, 500);
  }
});

// ── AI Training: Get training patterns ──────────────────
app.get("/make-server-f3f66941/ai/patterns", async (c) => {
  try {
    const type = c.req.query("type");
    const patterns = await getTrainingPatterns(type || undefined);
    return c.json({ patterns, count: patterns.length });
  } catch (err) {
    console.log(`Error listing training patterns: ${err}`);
    return c.json({ error: `Failed to list patterns: ${err}` }, 500);
  }
});

// ── AI Training: Get available model types ──────────────
app.get("/make-server-f3f66941/ai/model-types", (c) => {
  return c.json({ types: getModelTypes() });
});

// ── AI Generation: Generate a financial model via OpenAI ─
app.post("/make-server-f3f66941/ai/generate", async (c) => {
  try {
    const { prompt, modelType, companyName, industry, assumptions } = await c.req.json();
    if (!prompt) {
      return c.json({ error: "Missing required field: prompt" }, 400);
    }

    console.log(`AI model generation request: type=${modelType}, prompt="${prompt.substring(0, 80)}..."`);

    const model = await generateFinancialModel({
      prompt,
      modelType: modelType || "LBO",
      companyName,
      industry,
      assumptions,
    });

    // Also get cell data for Excel injection
    const cellData = modelToCellData(model);

    await logActivity({
      action: "generated AI model",
      target: model.name,
      user: "AI Engine",
    });

    console.log(`AI model generated: ${model.name} (${model.sheets.length} sheets, ${cellData.length} cells)`);
    return c.json({ model, cellData });
  } catch (err) {
    console.log(`Error generating AI model: ${err}`);
    return c.json({ error: `Model generation failed: ${err}` }, 500);
  }
});

// ── AI Generation: Get a previously generated model ─────
app.get("/make-server-f3f66941/ai/generated/:id", async (c) => {
  try {
    const id = c.req.param("id");
    const model = await kv.get(id.startsWith("generated:") ? id : `generated:${id}`);
    if (!model) {
      return c.json({ error: `Generated model not found: ${id}` }, 404);
    }
    const cellData = modelToCellData(model);
    return c.json({ model, cellData });
  } catch (err) {
    console.log(`Error getting generated model: ${err}`);
    return c.json({ error: `Failed to get generated model: ${err}` }, 500);
  }
});

// ── AI Generation: List generated models ────────────────
app.get("/make-server-f3f66941/ai/generated", async (c) => {
  try {
    const models = await kv.getByPrefix("generated:");
    const sorted = models
      .filter((m: any) => m && m.id)
      .sort((a: any, b: any) => new Date(b.metadata?.generatedAt || 0).getTime() - new Date(a.metadata?.generatedAt || 0).getTime());
    return c.json({ models: sorted });
  } catch (err) {
    console.log(`Error listing generated models: ${err}`);
    return c.json({ error: `Failed to list generated models: ${err}` }, 500);
  }
});

// ── Excel AI Agent: Upload file for chat context ─────────
// Accepts a file (XLSX, CSV, TXT, JSON, PDF), extracts content, returns text for AI context.
app.post("/make-server-f3f66941/ai/agent/upload", async (c) => {
  try {
    const formData = await c.req.formData();
    const file = formData.get("file") as File | null;
    if (!file) {
      return c.json({ error: "No file provided" }, 400);
    }

    const fileName = file.name || "unknown";
    const fileType = fileName.split(".").pop()?.toLowerCase() || "";
    const fileSize = file.size;
    console.log(`Agent file upload: ${fileName} (${fileType}, ${fileSize} bytes)`);

    let extractedContent = "";
    let metadata: Record<string, unknown> = { fileName, fileType, fileSize };

    if (fileType === "xlsx" || fileType === "xls" || fileType === "xlsm") {
      // Use existing XLSX parser
      try {
        const buffer = await file.arrayBuffer();
        const parsed = parseExcelBuffer(buffer, fileName, "General");
        if (parsed) {
          const sheetNames = parsed.sheets.map((s: any) => s.name);
          metadata.sheetNames = sheetNames;
          metadata.totalSheets = parsed.sheetCount;

          // Build a text summary of the workbook content
          const lines: string[] = [];
          lines.push(`=== Excel File: ${fileName} ===`);
          lines.push(`Sheets: ${sheetNames.join(", ")}`);
          lines.push(`Total formulas: ${parsed.totalFormulas}, Total cells: ${parsed.totalCells}`);
          lines.push(`Detected type: ${parsed.detectedType || parsed.modelType}`);

          for (const sheet of parsed.sheets) {
            lines.push(`\n--- Sheet: ${sheet.name} (${sheet.rowCount} rows x ${sheet.colCount} cols) ---`);
            if (sheet.headers && sheet.headers.length > 0) {
              lines.push(`Headers: ${sheet.headers.join(", ")}`);
            }
            if (sheet.sections && sheet.sections.length > 0) {
              lines.push(`Sections: ${sheet.sections.join(", ")}`);
            }
            // Assumptions
            const assumptionEntries = Object.entries(sheet.assumptions || {});
            if (assumptionEntries.length > 0) {
              lines.push(`Assumptions:`);
              for (const [key, info] of assumptionEntries.slice(0, 20)) {
                const a = info as any;
                lines.push(`  ${a.cell || ""}: ${key} = ${a.value}${a.format ? " (" + a.format + ")" : ""}`);
              }
            }
            // Sample data
            if (sheet.sampleData && sheet.sampleData.length > 0) {
              lines.push(`Sample data:`);
              for (const sd of sheet.sampleData.slice(0, 30)) {
                lines.push(`  ${sd.cell}: ${sd.value}${sd.bold ? " [bold]" : ""}`);
              }
            }
            // Formulas
            if (sheet.formulas && sheet.formulas.length > 0) {
              lines.push(`Key formulas:`);
              for (const f of sheet.formulas.slice(0, 20)) {
                lines.push(`  ${f.cell}: ${f.formula}`);
              }
            }
          }

          extractedContent = lines.join("\n");
        } else {
          extractedContent = `[Could not parse Excel file: ${fileName}]`;
        }
      } catch (parseErr) {
        console.log(`XLSX parse error: ${parseErr}`);
        extractedContent = `[Error parsing Excel file: ${parseErr}]`;
      }
    } else if (fileType === "csv") {
      extractedContent = await file.text();
      // Truncate if very large
      if (extractedContent.length > 50000) {
        extractedContent = extractedContent.substring(0, 50000) + "\n... (truncated)";
      }
      extractedContent = `=== CSV File: ${fileName} ===\n${extractedContent}`;
    } else if (fileType === "json") {
      const raw = await file.text();
      try {
        const parsed = JSON.parse(raw);
        extractedContent = `=== JSON File: ${fileName} ===\n${JSON.stringify(parsed, null, 2).substring(0, 50000)}`;
      } catch {
        extractedContent = `=== JSON File: ${fileName} ===\n${raw.substring(0, 50000)}`;
      }
    } else if (fileType === "txt" || fileType === "md" || fileType === "tsv") {
      const raw = await file.text();
      extractedContent = `=== Text File: ${fileName} ===\n${raw.substring(0, 50000)}`;
    } else {
      // Unsupported type — try reading as text
      try {
        const raw = await file.text();
        extractedContent = `=== File: ${fileName} ===\n${raw.substring(0, 30000)}`;
      } catch {
        extractedContent = `[Unsupported file type: ${fileType}. Could not extract content from ${fileName}]`;
      }
    }

    return c.json({
      success: true,
      fileName,
      fileType,
      fileSize,
      extractedContent,
      metadata,
    });
  } catch (err) {
    console.log(`Agent file upload error: ${err}`);
    return c.json({ error: `File upload failed: ${err}` }, 500);
  }
});

// ── Excel AI Agent: Get conversation messages ────────────
// Returns the messages for a specific session so the taskpane can restore chat history.
app.get("/make-server-f3f66941/ai/agent/sessions/:id", async (c) => {
  try {
    const sessionId = c.req.param("id");
    const session = await kv.get(`agent-session:${sessionId}`);
    if (!session) {
      return c.json({ error: `Session not found: ${sessionId}` }, 404);
    }
    const s = session as any;
    // Return a cleaned version of messages (skip system prompt, simplify tool calls)
    const messages = (s.messages || [])
      .filter((m: any) => m.role !== "system")
      .map((m: any) => ({
        role: m.role,
        content: m.content,
        tool_calls: m.tool_calls?.map((tc: any) => ({
          id: tc.id,
          name: tc.function?.name,
          arguments: tc.function?.arguments,
        })),
        tool_call_id: m.tool_call_id,
      }));

    return c.json({
      id: s.id,
      messages,
      modelType: s.modelType,
      createdAt: s.createdAt,
      lastActiveAt: s.lastActiveAt,
    });
  } catch (err) {
    console.log(`Error getting session ${c.req.param("id")}: ${err}`);
    return c.json({ error: `Failed to get session: ${err}` }, 500);
  }
});

// ── Excel AI Agent: Delete a session ─────────────────────
app.delete("/make-server-f3f66941/ai/agent/sessions/:id", async (c) => {
  try {
    const sessionId = c.req.param("id");
    await kv.del(`agent-session:${sessionId}`);
    console.log(`Agent session deleted: ${sessionId}`);
    return c.json({ success: true });
  } catch (err) {
    console.log(`Error deleting session ${c.req.param("id")}: ${err}`);
    return c.json({ error: `Failed to delete session: ${err}` }, 500);
  }
});

// ── Excel AI Agent: Start or continue agent conversation ──
// This is the core agent loop. The taskpane sends workbook context + user prompt,
// server calls OpenAI with tool definitions, returns tool_calls for local execution.
app.post("/make-server-f3f66941/ai/agent", async (c) => {
  try {
    const { sessionId, workbookContext, prompt, modelType } = await c.req.json();
    if (!prompt) {
      return c.json({ error: "Missing required field: prompt" }, 400);
    }

    console.log(`Agent request: session=${sessionId || "new"}, prompt="${prompt.substring(0, 80)}..."`);

    const result = await runAgentStep(
      sessionId || `session-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
      workbookContext || null,
      prompt,
      null, // no tool results on initial call
      modelType,
    );

    return c.json(result);
  } catch (err) {
    console.log(`Agent error: ${err}`);
    return c.json({ type: "error", error: `Agent failed: ${err}`, sessionId: "" }, 500);
  }
});

// ── Excel AI Agent: Continue after tool execution ────────
// Taskpane executed tools locally, sends results back for the next agent step.
app.post("/make-server-f3f66941/ai/agent/continue", async (c) => {
  try {
    const { sessionId, toolResults } = await c.req.json();
    if (!sessionId) {
      return c.json({ error: "Missing required field: sessionId" }, 400);
    }
    if (!toolResults || !toolResults.length) {
      return c.json({ error: "Missing required field: toolResults" }, 400);
    }

    console.log(`Agent continue: session=${sessionId}, ${toolResults.length} tool result(s)`);

    const result = await runAgentStep(
      sessionId,
      null, // no new workbook context on continue
      null, // no new prompt
      toolResults,
    );

    return c.json(result);
  } catch (err) {
    console.log(`Agent continue error: ${err}`);
    return c.json({ type: "error", error: `Agent continue failed: ${err}`, sessionId: "" }, 500);
  }
});

// ── Excel AI Agent: List sessions ────────────────────────
app.get("/make-server-f3f66941/ai/agent/sessions", async (c) => {
  try {
    const sessions = await kv.getByPrefix("agent-session:");
    const sorted = sessions
      .filter((s: any) => s && s.id)
      .sort((a: any, b: any) => new Date(b.lastActiveAt || 0).getTime() - new Date(a.lastActiveAt || 0).getTime())
      .slice(0, 20)
      .map((s: any) => ({
        id: s.id,
        messageCount: s.messages?.length || 0,
        modelType: s.modelType,
        createdAt: s.createdAt,
        lastActiveAt: s.lastActiveAt,
      }));
    return c.json({ sessions: sorted });
  } catch (err) {
    console.log(`Error listing agent sessions: ${err}`);
    return c.json({ error: `Failed to list sessions: ${err}` }, 500);
  }
});

Deno.serve(app.fetch);
